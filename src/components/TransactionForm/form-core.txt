/**
 * Core Form Implementation
 * 
 * Implements a robust form management system with:
 * - TypeScript for type safety
 * - React Context for state management
 * - Modular component architecture
 * - Comprehensive error handling
 */

import React, { createContext, useContext, useReducer, useMemo } from 'react';
import { z } from 'zod';
import { formSchema } from './validation/schemas';
import { CommandAPIService } from './services/commandSync';

// Types
export type FormState = z.infer<typeof formSchema>;

interface FormContextValue {
  state: FormState;
  dispatch: React.Dispatch<FormAction>;
  isSubmitting: boolean;
  currentStep: number;
}

type FormAction =
  | { type: 'SET_FIELD'; field: string; value: any }
  | { type: 'SET_ERROR'; field: string; error: string }
  | { type: 'CLEAR_ERROR'; field: string }
  | { type: 'NEXT_STEP' }
  | { type: 'PREV_STEP' }
  | { type: 'START_SUBMIT' }
  | { type: 'END_SUBMIT' }
  | { type: 'RESET_FORM' };

// Context Creation
const FormContext = createContext<FormContextValue | undefined>(undefined);

/**
 * Form state reducer with immutable updates
 * Handles all form actions and maintains state consistency
 */
function formReducer(state: FormState, action: FormAction): FormState {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        data: setIn(state.data, action.field, action.value),
        touched: {
          ...state.touched,
          [action.field]: true
        }
      };
      
    case 'SET_ERROR':
      return {
        ...state,
        errors: {
          ...state.errors,
          [action.field]: action.error
        }
      };
      
    case 'CLEAR_ERROR': {
      const { [action.field]: _, ...remainingErrors } = state.errors;
      return {
        ...state,
        errors: remainingErrors
      };
    }
    
    case 'NEXT_STEP':
      return {
        ...state,
        currentStep: Math.min(
          state.currentStep + 1,
          FORM_STEPS.length - 1
        )
      };
      
    case 'PREV_STEP':
      return {
        ...state,
        currentStep: Math.max(state.currentStep - 1, 0)
      };
      
    case 'START_SUBMIT':
      return {
        ...state,
        isSubmitting: true
      };
      
    case 'END_SUBMIT':
      return {
        ...state,
        isSubmitting: false
      };
      
    case 'RESET_FORM':
      return initialState;
      
    default:
      return state;
  }
}

/**
 * Form Provider Component
 * Provides form state and actions to all child components
 */
export const FormProvider: React.FC<{ children: React.ReactNode }> = ({
  children
}) => {
  const [state, dispatch] = useReducer(formReducer, initialState);
  
  const contextValue = useMemo(() => ({
    state,
    dispatch,
    isSubmitting: state.isSubmitting,
    currentStep: state.currentStep
  }), [state]);

  return (
    <FormContext.Provider value={contextValue}>
      {children}
    </FormContext.Provider>
  );
};

/**
 * Custom hook for accessing form context
 * Provides type-safe access to form state and actions
 */
export function useForm() {
  const context = useContext(FormContext);
  if (!context) {
    throw new Error('useForm must be used within FormProvider');
  }
  return context;
}

/**
 * Form Container Component
 * Handles form submission and validation
 */
export const FormContainer: React.FC = () => {
  const { state, dispatch } = useForm();
  const commandApi = useCommandAPI();
  const validation = useFormValidation();
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    dispatch({ type: 'START_SUBMIT' });
    
    try {
      // Validate entire form
      const isValid = await validation.validateForm();
      if (!isValid) {
        return;
      }
      
      // Transform and submit data
      const payload = transformForCommand(state.data);
      await commandApi.submitTransaction(payload);
      
      dispatch({ type: 'END_SUBMIT' });
      // Handle success (redirect, show message, etc.)
    } catch (error) {
      dispatch({ type: 'END_SUBMIT' });
      // Handle error (show message, retry, etc.)
    }
  };

  return (
    <form onSubmit={handleSubmit} className="form-container">
      {/* Form progress indicator */}
      <FormProgress
        currentStep={state.currentStep}
        steps={FORM_STEPS}
        errors={state.errors}
      />
      
      {/* Dynamic form sections */}
      {state.currentStep === 0 && <RoleSection />}
      {state.currentStep === 1 && <PropertySection />}
      {state.currentStep === 2 && <ClientSection />}
      {state.currentStep === 3 && <CommissionSection />}
      {state.currentStep === 4 && <DocumentsSection />}
      
      {/* Navigation controls */}
      <FormNavigation
        currentStep={state.currentStep}
        totalSteps={FORM_STEPS.length}
        isValid={!Object.keys(state.errors).length}
        isSubmitting={state.isSubmitting}
        onNext={() => dispatch({ type: 'NEXT_STEP' })}
        onPrev={() => dispatch({ type: 'PREV_STEP' })}
      />
    </form>
  );
};